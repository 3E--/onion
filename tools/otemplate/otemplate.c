/*
	Onion HTTP server library
	Copyright (C) 2010-2011 David Moreno Montero

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU Affero General Public License as
	published by the Free Software Foundation, either version 3 of the
	License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Affero General Public License for more details.

	You should have received a copy of the GNU Affero General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.
	*/

#define _GNU_SOURCE
#include <string.h>
#include <ctype.h>
#include <libgen.h>
#include <stdarg.h>
#include <malloc.h>

#include "onion/log.h"
#include "onion/block.h"
#include "list.h"
#include "parser.h"
#include "tags.h"

list *plugin_search_path;

int work(const char *infilename, const char *outfilename);

int main(int argc, char **argv){
	if (argc!=3){
		ONION_ERROR("Usage: otemplate <inputfile> <outputfile>");
		return 1;
	}
	
	// Add some plugin searhc paths
	plugin_search_path=list_new(NULL);
	list_add(plugin_search_path, "lib%s.so");
	list_add(plugin_search_path, "templatetags/lib%s.so");
	char tmp[256];
	snprintf(tmp, sizeof(tmp), "%s/templatetags/lib%%s.so", dirname(strdupa(argv[0])));
	list_add(plugin_search_path, strdupa(tmp)); // dupa is ok, as im at main.
	snprintf(tmp, sizeof(tmp), "%s/lib%%s.so", dirname(strdupa(argv[0])));
	list_add(plugin_search_path, strdupa(tmp)); // dupa is ok, as im at main.
	list_add(plugin_search_path, "/usr/local/lib/otemplate/templatetags/lib%s.so");
	list_add(plugin_search_path, "/usr/lib/otemplate/templatetags/lib%s.so");
	
	
	const char *infilename;
	const char *outfilename;
	if (strcmp(argv[1], "-")==0){
		infilename="";
	}
	else{
		infilename=argv[1];
		char tmp[256];
		snprintf(tmp, sizeof(tmp), "%s/lib%%s.so", dirname(strdupa(argv[1])));
		list_add(plugin_search_path, strdupa(tmp));
		snprintf(tmp, sizeof(tmp), "%s/templatetags/lib%%s.so", dirname(strdupa(argv[1])));
		list_add(plugin_search_path, strdupa(tmp));
	}

	outfilename=argv[2];
	

	int error=work(infilename, outfilename);
	
	list_free(plugin_search_path);
	
	return error;
}


int work(const char *infilename, const char *outfilename){
	tag_init();
	parser_status status;
	memset(&status, 0, sizeof(status));
	status.mode=TEXT;
	status.functions=list_new((void*)function_free);
	status.function_stack=list_new(NULL);
	status.status=0;
	status.line=1;
	status.rawblock=onion_block_new();
	status.infilename=infilename;
	
	if (strcmp(infilename, "-")==0)
		status.in=stdin;
	else
		status.in=fopen(infilename,"rt");
	
	if (!status.in){
		ONION_ERROR("Could not open in file %s", infilename);
		goto work_end;
	}

	function_new(&status, basename(strdupa(infilename)));
	
	parse_template(&status);
	
	if (status.status){
		ONION_ERROR("Parsing error");
		goto work_end;
	}

	if (strcmp(outfilename, "-")==0)
		status.out=stdout;
	else
		status.out=fopen(outfilename,"wt");
	if (!status.out){
		ONION_ERROR("Could not open out file %s", infilename);
		goto work_end;
	}
	
	fprintf(status.out,
"/** Autogenerated by otemplate v. 0.0.0 */\n"
"\n"
"#include <libintl.h>\n"
"#include <string.h>\n\n"
"#include <onion/onion.h>\n"
"#include <onion/dict.h>\n"
"\n"
"typedef struct dict_res_t{\n"
"	onion_dict *dict;\n"
"	onion_response *res;\n"
"}dict_res;\n"
"\n"
"\n");
	
	functions_write_declarations(&status);

	functions_write_main_code(&status);


	functions_write_code(&status);

work_end:
	if (status.in)
		fclose(status.in);
	if (status.out)
		fclose(status.out);
	list_free(status.functions);
	list_free(status.function_stack);
	onion_block_free(status.rawblock);
	
	tag_free();
	return status.status;
}

